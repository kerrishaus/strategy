<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>strategy</title>
		<style>
			body
			{
			    margin: 0;
			    background: navy;
			    font-family: Tahoma;
			}
		</style>
		
		<script src="https://kerrishaus.com/assets/scripts/jquery-3.6.0.min.js"></script>
		
		<link rel='stylesheet' href='https://kerrishaus.com/games/strategy/assets/styles/interface.css' />
		
		<script>
            const params = new URLSearchParams(window.location.search);
            
            if (params.has("debug"))
            {
                $("head").append("<script src='https://portal.kerrishaus.com/assets/javascript/messages.js'><\/script>");
                $("head").append("<link rel='stylesheet' href='https://portal.kerrishaus.com/assets/styles/messages.css' />");
            }
        </script>
	</head>
	
	<body>
	    <script>
	        if (!params.has("skipLoading"))
	            $("body").prepend("<div id='loadingCover'><div id='status'><img id='kerris' src='https://kerrishaus.com/assets/logo/text-big.png'></img><img id='threejs' src='https://bachasoftware.com/wp-content/uploads/2020/07/icon_2-1.png'></img><img id='webgl' src='https://upload.wikimedia.org/wikipedia/commons/thumb/2/25/WebGL_Logo.svg/1024px-WebGL_Logo.svg.png'></img></div><div class='help'>Copyright &copy;&nbsp;<span translate='no'>Kerris Haus</span></div></div>");
        </script>
	    
	    <div class='gameInterfaceContainer transition-quick'>
	        <div class='gameStatus moveableInterfaceElement' data-state='0'>
	            <div id='me'>
	                <div id='playerPortrait'></div>
	            </div>
	            <div id='roundStatus'>
	                <div>
	                    <span id='flag'></span>
	                    <span id='playerName'>Super Idiot</span>
	                    <span id='tags'>&#10004;</span>
	                </div>
	                <div id='roundType'>
	                    <div class='roundSpace active'>Place</div>
	                    <div class='roundSpace'>Attack</div>
	                    <div class='roundSpace'>Move</div>
	                </div>
                    <button id='nextStateButton'>
                        next state
                    </button>
	            </div>
	            <div id='counter'>
	                <div id='statue'>
	                    
	                </div>
	                <div id='count'>
	                    
	                </div>
	            </div>
	        </div>
            <div class='attackPlanner'>
                <div class='cancelButton moveableInterfaceElement'>
                    <button id='attackPlannerCancelButton'>cancel</button>
                </div>
                <div class='attacker moveableInterfaceElement'>
                    <h1>Attacking</h1>
                    <!--<div style='width: 400px;height: 500px;background-color:red;border-radius:10px;'>-->
                    <div class=''>
                        <span id='attackerCount'></span>
                    </div>
                </div>
                <div>
                    <h1>vs</h1>
                </div>
                <div class='defender moveableInterfaceElement'>
                    <h1>Defending</h1>
                    <!--<div style='width: 400px;height: 500px;background-color:blue;border-radius:10px;'>-->
                    <div class=''>
                        <span id='defenderCount'></span>
                    </div>
                </div>
                <div class='attackGoButton moveableInterfaceElement'>
                    <button id='attackPlannerGoButton'>Go!</button>
                </div>
            </div>
            <div id='gameWin'>
                <h1>You win!</h1>
                <button id='replayGame'>Replay</button>
            </div>
	    </div>
	    
	    <!--
	    <div id='dropUnitDialog'>
	        <div>How many units?</div>
	        <div>
	            <input type="range" min="1" max="4" value="2" class="slider" id="dropUnitAmount"> <span id='dropUnitAmountPreview'>0</span>
            </div>
            <div>
	            <button id='dropUnitButton'>Drop Units</button>
            </div>
	    </div>
	    -->
	    
		<script src="https://kerrishaus.com/assets/threejs/build/three.js"></script>

		<script type='module'>
		    import { CSS2DObject, CSS2DRenderer } from "https://kerrishaus.com/assets/threejs/examples/jsm/renderers/CSS2DRenderer.js";

            function getRandomInt(max)
            {
                return Math.floor(Math.random() * max);
            }

		    const ownedColor                 = 0x00aa00, 
		          ownedHoverColor            = 0x00cc00, 
		          ownedSelectedColor         = 0x00ff00, 

		          enemyColor                 = 0xaa0000, 
		          enemyInvadeableColor       = 0xee0000,
		          enemyInvadeablePausedColor = 0x550000,
		          enemyInvadeableHoverColor  = 0xcc0000, 
		          enemySelectedColor         = 0xff0000;

			class WorldObject extends THREE.Mesh
			{
			    constructor(width, height, color)
			    {
			        const geometry = new THREE.BoxGeometry(width, height, 1);
			        const material = new THREE.MeshBasicMaterial({ color: color });
			        
			        super(geometry, material);
			        
			        this.hovered = false;
			        
			        this.objectOwner = -1;
			        this.unitCount = 1;
			        
    				const labelDiv = document.createElement("div");
    				labelDiv.id = this.uuid;
        			labelDiv.className = 'unitCount';
        			labelDiv.textContent = this.unitCount;
        			
        			this.label = new CSS2DObject(labelDiv);
        			this.label.color = "white";
        			this.add(this.label);
        			
        			this.userData.canClick = true;
        			
        			this.targetPosition = new THREE.Vector3(0, 0, 0);
        			
        			this.dialog = null;
        			this.world = null;
        			this.invadeableNeighbors = new Array(4);
			    }
			    
			    update(deltaTime)
			    {
			        this.position.lerp(this.targetPosition, 0.3);
			    }
			    
			    getInvadeableNeighbors()
			    {
			        return this.invadeableNeighbors;
			    }
			    
			    createUnitPlaceDialog(availableUnits)
			    {
			        if (this.availableUnits <= 0)
			        {
			            console.warn("No available units to place.");
			            return
			        }
			        
			        if (this.dialog)
			            this.destroyUnitPlaceDialog();
			        
    				const dialog = document.createElement("div");
        			dialog.id = 'unitPlaceDialog';
        			
        			const header = document.createElement("h1");
        			header.innerHTML = "Place how many units?";
        			dialog.append(header);
        			
        			const inputGroup = document.createElement("div");
        			dialog.append(inputGroup);
        			
        			const input = document.createElement("input");
        			input.id = 'dropUnitAmount';
        			input.type = 'range'
        			input.min = 1;
        			input.max = availableUnits;
        			input.value = availableUnits;
        			input.addEventListener("input", function(event)
        			{
        			    document.getElementById("dropUnitAmountPreview").innerHTML = this.value;
        			});
        			inputGroup.append(input);
        			
        			const inputCounter = document.createElement("span");
        			inputCounter.textContent = availableUnits;
        			inputCounter.id = 'dropUnitAmountPreview'
        			inputGroup.append(inputCounter);
        			
        			const button = document.createElement("button");
        			button.id = 'dropUnitButton';
        			button.textContent = "Place";
        			dialog.append(button);
        			
        			this.dialog = new CSS2DObject(dialog);
        			this.add(this.dialog);
			    }
			    
			    destroyUnitPlaceDialog()
			    {
        			this.remove(this.dialog);
        			delete this.dialog;
        			this.dialog = null;
			    }
			    
			    createUnitMoveDialog(units)
			    {
			        if (this.dialog)
			            this.destroyUnitMoveDialog();
			            
		            console.log(units);
			        
    				const dialog = document.createElement("div");
        			dialog.id = 'unitMoveDialog';
        			
        			const header = document.createElement("h1");
        			header.innerHTML = "Move how many units?";
        			dialog.append(header);
        			
        			const inputGroup = document.createElement("div");
        			dialog.append(inputGroup);
        			
        			const input = document.createElement("input");
        			input.id = 'moveUnitAmount';
        			input.type = 'range'
        			input.min = 1;
        			input.max = units;
        			input.value = units;
        			input.addEventListener("input", function(event)
        			{
        			    document.getElementById("moveUnitAmountPreview").innerHTML = this.value;
        			});
        			inputGroup.append(input);
        			
        			const inputCounter = document.createElement("span");
        			inputCounter.textContent = units;
        			inputCounter.id = 'moveUnitAmountPreview'
        			inputGroup.append(inputCounter);
        			
        			const button = document.createElement("button");
        			button.id = 'moveUnitButton';
        			button.textContent = "Place";
        			dialog.append(button);
        			
        			this.dialog = new CSS2DObject(dialog);
        			this.add(this.dialog);
			    }
			    
			    destroyUnitMoveDialog()
			    {
        			this.remove(this.dialog);
        			delete this.dialog;
        			this.dialog = null;
			    }
			    
			    /*
			    onHover()
			    {
			        this.raise();
			    }
			    
			    onStopHover()
			    {
			        this.lower();
			    }
			    */
			    
			    raise()
			    {
			        this.targetPosition.z = 0.4;
			    }
			    
			    lower()
			    {
			        this.targetPosition.z = 0;
			    }
			    
			    addUnits(amount = 1)
			    {
			        this.unitCount += amount;
			        $("#" + this.uuid).html(this.unitCount);
			    }
			    
			    removeUnits(amount = 1)
			    {
			        this.unitCount -= amount;
			        $("#" + this.uuid).html(this.unitCount);
			    }
			};

			/*
			class Territory extends WorldObject
			{
			    construct(color)
			    {
			        super(1, 1, color);
			    }
			}
			
			class ownedTerritories extends Territory
			{
			    construct()
			    {
			        this.team = 1;
			    }
			}
			
			class EnemyTerritory extends Territory
			{
			    construct()
			    {
			        this.team = 2;
			    }
			}
			*/

			class GameWorld extends THREE.Group
			{
			    constructor(width, height)
			    {
			        super();
			        
			        this.height = height;
			        this.width = width;
			        
			        this.tiles = new Array(this.width * this.height);
			        
			        this.ownedTerritories = 0;
			        
		            for (let y = 0; y < this.height; y++)
			        {
			            for (let x = 0; x < this.width; x++)
			            {
                            let chance = getRandomInt(2);
                            
                            let color = enemyColor;
			                if (chance > 0)
			                {
			                    color = ownedColor;
			                    this.ownedTerritories += 1;
			                }
			                
			                const arrayPosition = x + y * this.width;
			                
			                const object = new WorldObject(2, 2, color);
			                
			                object.targetPosition.x = x + 1.0 * x;
			                object.targetPosition.y = y + 1.0 * y;
			                object.targetPosition.z = 0;
			                
			                object.unitCount = getRandomInt(4) + 1;
			                
			                object.userData.team = chance > 0 ? 1 : 2;
			                object.userData.invadeable = false;
			                object.userData.territoryId = arrayPosition;
			                
			                object.label.element.innerHTML = object.unitCount;
			                
			                this.tiles[arrayPosition] = object;
			                this.add(object);
			            }
			            
			        }
			        
                    this.calculateInvadeableTerritories();
			        
                    const floorGeometry = new THREE.PlaneGeometry(width + width * 1.3 + 3, height + height * 1.3 + 3);
                    const floorMaterial = new THREE.MeshBasicMaterial({color: 0x256d8f, side: THREE.FrontSide });
                    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                    floor.position.x = width / 2 + 1.1 * width / 2 - 0.7;
                    floor.position.y = height / 2 + 1.1 * height / 2 - 0.7;
                    this.add(floor);
			    }
			    
			    update(deltaTime)
			    {
			        for (const tile of this.tiles)
		                tile.update(deltaTime);
	            }
	            
	            add(object)
	            {
	                object.world = this;
	                super.add(object);
	            }
	            
	            calculateInvadeableTerritories()
	            {
		            // calculate invadeable neighbors
		            for (const tile of this.tiles)
		            {
		                const id = tile.userData.territoryId;
		                
		                delete tile.invadeableNeighbors;
		                tile.invadeableNeighbors = new Array(4);
		                
		                if (id - 1 >= 0)
		                    if (Math.trunc((id - 1) / this.width) == Math.trunc(id / this.width))
    		                    tile.invadeableNeighbors[0] = this.tiles[id - 1].userData.team != 1 ? this.tiles[id - 1] : null;
    		                
                        if (id + 1 < this.tiles.length)
                            if (Math.trunc((id + 1) / this.width) == Math.trunc(id / this.width))
                                tile.invadeableNeighbors[1] = this.tiles[id + 1].userData.team != 1 ? this.tiles[id + 1] : null;
		                    
	                    if (id - this.width >= 0)
	                        tile.invadeableNeighbors[2]     = this.tiles[id - this.width].userData.team != 1 ? this.tiles[id - this.width] : null;
                        else
	                        tile.invadeableNeighbors[2]     = null
	                        
                        if (id + this.width < this.tiles.length)
	                        tile.invadeableNeighbors[3]     = this.tiles[id + this.width].userData.team != 1 ? this.tiles[id + this.width] : null;
                        else
                            tile.invadeableNeighbors[3]     = null
	                        
                        if (tile.invadeableNeighbors[0] === null &&
                            tile.invadeableNeighbors[1] === null &&
                            tile.invadeableNeighbors[2] === null &&
                            tile.invadeableNeighbors[3] === null)
                            {
                                tile.invadeableNeighbors = null;
                                console.log(id + " has no invadeable neighbors.");
                            }
		            }
	            }
			};

			class StateMachine
			{
			    constructor(renderer, htmlRenderer)
			    {
			        this.states = new Array();
			        
			        this.renderer = renderer;
			        this.htmlRenderer = htmlRenderer;
			        
			        console.log("StateMachine is ready.");
			    }
			    
			    cleanup()
			    {
			        for (state of this.states)
			        {
			            state.cleanup();
			            state = null;
			        }
			        
			        this.states.length = 0;
			        
			        console.log("StateMachine is cleaned up.");
			    }
			    
			    pushState(state)
			    {
			        if (this.states > 1)
			            this.states[this.states.length - 1].pause();
			            
			        this.states.push(state);
			        this.states[this.states.length - 1].init(this);
			        
			        console.log("Pushed new state.");
			    }
			    
			    popState()
			    {
			        this.states[this.states.length - 1].cleanup();
			        this.states.pop();
			        
			        if (this.states.length > 0)
		                this.states[this.states.length - 1].resume();
		                
	                console.log("Popped state.");
			    }
			    
			    changeState(state)
			    {
			        this.popState();
			        this.pushState(state);
			        
			        console.log("Changed state.");
			    }
			    
			    setStateNumber(number)
			    {
			        gameState = number;
			        setGameState();
			    }
			    
			    onHover(object)
			    {
			        this.states[this.states.length - 1].onHover(object);
			    }
			    
			    onStopHover(object)
			    {
			        this.states[this.states.length - 1].onStopHover(object);
			    }
			    
			    onMouseDown(event, object)
			    {
			        this.states[this.states.length - 1].onMouseDown(event, object);
			    }
			    
			    onKeyDown(event)
			    {
			        this.states[this.states.length - 1].onKeyDown(event);
			    }
			    
			    update(deltaTime)
			    {
			        if (this.states.length > 0)
			            this.states[this.states.length - 1].update(deltaTime);
			    }
			};

			class State
			{
			    constructor()
			    {
			        this.stateNumber = -1;
			    }
			    
			    init(stateMachine)
			    {
			        this.stateMachine = stateMachine;
			        this.stateMachine.setStateNumber(this.stateNumber);
			    }
			    
			    cleanup()
			    {
			        
			    }
			    
			    pause()
			    {
			        
			    }
			    
			    resume()
			    {
			        
			    }
			    
			    onHover(object)
			    {
			        
			    }
			    
			    onStopHover(object)
			    {
			        
			    }
			    
			    onMouseDown(event, object)
			    {
			        
			    }
			    
			    onKeyDown(event)
			    {
			        
			    }
			    
			    update(deltaTime)
			    {
			        
			    }
			};
		    
			class UnitDropState extends State
			{
			    constructor(availableUnits)
			    {
			        super();
			        
			        this.availableUnits = availableUnits;
			        
			        this.selectedTerritory = null;
			    }
			    
			    init(stateMachine)
			    {
			        this.stateMachine = stateMachine;
			        this.stateMachine.setStateNumber(0);
			        
			        console.log("UnitDropState ready.");
			        
			        this.selectedTerritory = null;
			        
			        $("#count").html(this.availableUnits);
			        
        			$(htmlRenderer.domElement).on("click", "#dropUnitButton", callback =>
        			{
        			    if (this.selectedTerritory === null)
        			    {
        			        console.error("selectedTerritory is null.");
        			    }
        			    
        			    const amount = parseInt($("#dropUnitAmount").val());
        			    
        			    if (amount <= 0)
        		        {
        			        console.error("No available units to drop.");
        			        return;
        			    }
        			    
        			    if (amount > this.availableUnits)
        			    {
        			        console.error("Requested to drop too many units.");
        			        return;
        			    }
        			   
                        this.availableUnits -= amount;
                        this.selectedTerritory.addUnits(amount);
                        
                        if (this.availableUnits <= 0)
                        {
                            this.selectedTerritory.destroyUnitPlaceDialog();
                            this.selectedTerritory.lower();
                            this.selectedTerritory.material.color.setHex(ownedColor);
                            this.selectedTerritory = null;
                            
                            this.stateMachine.changeState(new AttackState());
                        }
                        
                        $("#count").html(this.availableUnits);
        			});
			    }
			    
			    cleanup()
			    {
			        console.log("UnitDropState cleaned up.");
			        
			        $(htmlRenderer).off("click", "#dropUnitButton");
			    }
			    
			    onHover(object)
			    {
                    if (object.userData.team != 1)
                        return;
                    
                    if (this.selectedTerritory !== object)
                    {
                        if (this.availableUnits > 0)
                        {
    	                    object.raise();
    	                    object.material.color.setHex(ownedHoverColor);
                        }
                    }
			    }
			    
			    onStopHover(object)
			    {
			        if (object.userData.team != 1)
			            return;
			            
		            if (object == this.selectedTerritory)
		                return
		                
	                object.lower();
	                object.material.color.setHex(ownedColor);
			    }
			    
			    onMouseDown(event, object)
			    {
			        if (object.userData.team == 1)
			        {
			            if (object == this.selectedTerritory)
			                return;
			                
    			        if (this.availableUnits <= 0)
    			        {
    			            console.error("You have no more deployable units.");
    			            return;
    			        }
			            
                        if (this.selectedTerritory !== null)
                        {
                            this.selectedTerritory.lower();
                            this.selectedTerritory.material.color.setHex(ownedColor);
                            this.selectedTerritory.destroyUnitPlaceDialog();
                            this.selectedTerritory = null;
                        }
                        
                        this.selectedTerritory = object;
                        this.selectedTerritory.raise();
                        this.selectedTerritory.material.color.setHex(ownedSelectedColor);
                        this.selectedTerritory.createUnitPlaceDialog(this.availableUnits);
			        }
			    }
			    
			    onKeyDown(event)
			    {
			        if (event.code == "Escape")
			            if (this.selectedTerritory !== null)
			            {
			                this.selectedTerritory.lower();
			                this.selectedTerritory.material.color.setHex(ownedColor);
			                this.selectedTerritory.destroyUnitPlaceDialog();
			                this.selectedTerritory = null;
			            }
			    }
			    
			    update(deltaTime)
			    {
			        
			    }
			};

			class UnitMoveState extends State
			{
			    constructor()
			    {
			        super();
			        
			        this.startTerritory = null;
			        this.endTerritory = null;
			    }
			    
			    init(stateMachine)
			    {
			        this.stateMachine = stateMachine;
			        this.stateMachine.setStateNumber(2);
			        
        			$(htmlRenderer.domElement).on("click", "#moveUnitButton", callback =>
        			{
        			    if (this.startTerritory === null)
        			    {
        			        console.error("startTerritory is null.");
        			        return;
        			    }
        			    
        			    if (this.endTerritory === null)
        			    {
        			        console.error("endTerritory is null.");
        			        return;
        			    }
        			    
        			    const amount = parseInt($("#moveUnitAmount").val());
        			    
        			    if (amount <= 0)
        		        {
        			        console.error("0 units chosen.");
        			        return;
        			    }
        			    
        			    // 1 unit must stay behind to maintain ownership of territory
        			    if (amount > this.startTerritory.unitCount - 1)
        			    {
        			        console.error("Requested to move too many units.");
        			        return;
        			    }

                        this.startTerritory.unitCount -= amount;
                        this.endTerritory.unitCount += amount;
                        
                        this.startTerritory.label.element.innerHTML = this.startTerritory.unitCount;
                        this.endTerritory.label.element.innerHTML = this.endTerritory.unitCount;

                        console.log(this.stateMachine);

                        // change the state after the units have been moved,
                        // as you can only move once during this turn.
                        this.stateMachine.changeState(new UnitDropState(world.ownedTerritories / 3));
        			});
			    }

			    cleanup()
			    {
			        if (this.startTerritory !== null)
			            this.clearStartPoint();

			        if (this.endTerritory !== null)
			            this.clearEndPoint();
			    }

			    pause()
			    {
			        
			    }

			    resume()
			    {
			        
			    }

			    onHover(object)
			    {
			        if (object.userData.team != 1)
			            return;
                    
		            if (this.startTerritory === null ||
		               (object !== this.startTerritory && this.endTerritory === null))
		            {
		                object.raise();
		                object.material.color.setHex(ownedHoverColor);
		            }
			    }
			    
			    onStopHover(object)
			    {
			        if (object.userData.team != 1)
			            return;
			        
                    if (this.startTerritory != object &&
                        this.endTerritory != object)
                    {
                        object.lower();
                        object.material.color.setHex(ownedColor);
                    }
                }
			    
			    onMouseDown(event, object)
			    {
			        if (object.userData.team != 1)
			            return;
			        
			        if (this.startTerritory === null)
			            this.setStartPoint(object);
			        else if (this.endTerritory === null)
			            this.setEndPoint(object);
			    }

			    onKeyDown(event)
			    {
			        if (event.code == "Escape")
                        if (this.endTerritory !== null)
                            this.clearEndPoint();
                        else if (this.startTerritory !== null)
                            this.clearStartPoint();
			    }
			    
			    update(deltaTime)
			    {
			        
			    }
			    
			    setStartPoint(object)
			    {
			        if (object.unitCount <= 1)
			        {
			            console.warn("This territory does not have enough units.");
			            return;
			        }
			        
			        object.raise();
			        object.material.color.setHex(ownedSelectedColor);
			        this.startTerritory = object;
			    }
			    
			    clearStartPoint()
			    {
			        // not strictly necessary, just prevents weird shit
			        if (this.endTerritory !== null)
			            this.clearEndPoint();
			        
			        this.startTerritory.lower();
			        this.startTerritory.material.color.setHex(ownedColor);
			        this.startTerritory = null;
			    }
			    
			    setEndPoint(object)
			    {
			        if (this.startTerritory === null)
			        {
			            console.error("startTerritory is null.");
			            return;
			        }
			        
			        if (this.endTerritory !== null)
			            this.clearEndPoint();
			        
		            object.raise();
		            object.material.color.setHex(ownedSelectedColor);
		            object.createUnitMoveDialog(this.startTerritory.unitCount - 1);
		            this.endTerritory = object;
			    }
			    
			    clearEndPoint()
			    {
			        this.endTerritory.lower();
			        this.endTerritory.material.color.setHex(ownedColor);
			        this.endTerritory.destroyUnitMoveDialog();
			        this.endTerritory = null;
			    }
			};

			class AttackState extends State
			{
			    constructor()
			    {
			        super();

			        this.selectedTerritory = null;
			        this.attackTerritory = null;

			        this.stateNumber = 1;
			    }

			    init(stateMachine)
			    {
			        this.stateMachine = stateMachine;
			        this.stateMachine.setStateNumber(this.stateNumber);

			        console.log("AttackState is ready.");
			    }

			    cleanup()
			    {
			        if (this.attackTerritory !== null)
			            this.clearDefendingTerritory();
			        
			        if (this.selectedTerritory !== null)
			            this.clearAttackingTerritory();
			    }

			    onHover(object)
			    {
			        if (this.selectedTerritory === null)
			        {
			            if (object.userData.team != 1)
			                return;
			                
			            if (object.invadeableNeighbors === null)
			                return;

		                object.raise();
		                object.material.color.setHex(ownedHoverColor);
			        }

			        if (this.attackTerritory === null)
			        {
			            if (object.userData.team == 1)
			                return;

		                if (!object.userData.invadeable)
		                    return;

		                object.raise();
		                object.material.color.setHex(enemyInvadeableHoverColor);
			        }
			    }

			    onStopHover(object)
			    {
			        if (object !== this.selectedTerritory &&
			            object !== this.attackTerritory)
			            {
		                    object.lower();
		                    
			                if (object.userData.team == 1)
			                    object.material.color.setHex(ownedColor);
			                else
			                    if (object.userData.invadeable)
			                        if (this.attackTerritory !== null)
			                            object.material.color.setHex(enemyInvadeablePausedColor);
			                        else
			                            object.material.color.setHex(enemyInvadeableColor);
			                    else
			                        object.material.color.setHex(enemyColor);
			            }
			    }

			    onMouseDown(event, object)
			    {
			        if (this.attackTerritory === null && object.userData.team == 1)
			            this.setAttackingTerritory(object);
			        else if (this.attackTerritory === null && object.userData.team != 1)
			            this.setDefendingTerritory(object);
			        else
			            console.error("Invalid object clicked during AttackState.");
			    }

			    onKeyDown(event)
			    {
			        if (event.code == "Escape")
			        {
			            if (this.attackTerritory !== null)
			                this.clearDefendingTerritory();
		                else if (this.selectedTerritory !== null)
		                    this.clearAttackingTerritory();
			        }
			    }

			    update(deltaTime)
			    {

			    }

			    setAttackingTerritory(object)
			    {
			        if (object.invadeableNeighbors === null)
			        {
			            console.error("This tile cannot invade any of its neighbors.");
			            return;
			        }
			        
			        if (this.selectedTerritory !== null)
			            this.clearAttackingTerritory();
			            
		            object.raise();
		            object.material.color.setHex(ownedSelectedColor);
		            this.selectedTerritory = object;

                    if (this.selectedTerritory.invadeableNeighbors !== null)
        			    for (const tile of this.selectedTerritory.getInvadeableNeighbors())
        			    {
        			        if (!(tile instanceof WorldObject))
        			            continue;
    
        	                tile.userData.invadeable = true;
        	                tile.material.color.setHex(enemyInvadeableColor);
        			    }
			    }
			    
			    clearAttackingTerritory()
			    {
			        if (this.selectedTerritory === null)
			        {
			            console.error("selectedTerritory is null in clearAttackingTerritory()");
			            return;
			        }

			        if (this.attackTerritory !== null)
			            this.clearDefendingTerritory();
			            
		            if (this.selectedTerritory.invadeableNeighbors !== null)
        			    for (const tile of this.selectedTerritory.getInvadeableNeighbors())
        			    {
        			        if (!(tile instanceof WorldObject))
        			            continue;
    
        	                tile.userData.invadeable = false;
        	                tile.material.color.setHex(enemyColor);
        			    }

			        this.selectedTerritory.lower();
			        this.selectedTerritory.material.color.setHex(ownedColor);
			        this.selectedTerritory = null;
			    }
			    
			    setDefendingTerritory(object)
			    {
			        if (this.selectedTerritory === null)
			        {
			            console.error("selectedTerritory must be set before attackTerritory can be set.");
			            return;
			        }

			        if (object == this.selectedTerritory)
			        {
			            console.error("attackTerritory cannot be selectedTerritory.");
			            return;
			        }
			        
			        if (!object.userData.invadeable)
			        {
			            console.error("This tile is not invadeable.");
			            return;
			        }
			        
			        object.raise();
			        object.material.color.setHex(enemySelectedColor);
			        this.attackTerritory = object;
			        
    			    for (const tile of this.selectedTerritory.getInvadeableNeighbors())
    			    {
    			        if (!(tile instanceof WorldObject))
    			            continue;
    			            
			            if (tile === this.attackTerritory)
			                continue;

    	                tile.userData.invadeable = true;
    	                tile.material.color.setHex(enemyInvadeablePausedColor);
    			    }
			        
    			    $("#attackerCount").html(this.selectedTerritory.unitCount);
    			    $("#defenderCount").html(this.attackTerritory.unitCount);
    			    $(".gameInterfaceContainer").attr("data-visibility", "hidden");
			    }
			    
			    clearDefendingTerritory()
			    {
			        if (this.attackTerritory === null)
			        {
			            console.error("attackTerritory is null.");
			            return;
			        }
			        
			        this.attackTerritory.lower();
			        this.attackTerritory.material.color.setHex(enemyInvadeableColor);
			        this.attackTerritory = null;
			        
    			    for (const tile of this.selectedTerritory.getInvadeableNeighbors())
    			    {
    			        if (!(tile instanceof WorldObject))
    			            continue;
    			            
			            if (tile === this.attackTerritory)
			                continue;

    	                tile.userData.invadeable = true;
    	                tile.material.color.setHex(enemyInvadeableColor);
    			    }
			        
			        $(".gameInterfaceContainer").attr("data-visibility", null);
			    }
			};
			
			const scene = new THREE.Scene();
			const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

			const cameraPosition = new THREE.Vector3(5 + 0.3 * 5, 5 + 0.3 * 5, 14);

			const renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setClearColor(0x256d8f);
			document.body.appendChild(renderer.domElement);

			const htmlRenderer = new CSS2DRenderer();
			htmlRenderer.setSize(window.innerWidth, window.innerHeight);
			htmlRenderer.domElement.style.position = 'absolute';
			htmlRenderer.domElement.style.top = '0px';
			document.body.appendChild(htmlRenderer.domElement).style.pointerEvents = "none";

			const stateManager = new StateMachine(renderer, htmlRenderer);

			let raycaster = new THREE.Raycaster(), pointer = new THREE.Vector2, INTERSECTED;

			const clock = new THREE.Clock();

			window.addEventListener('resize', onWindowResize);

			document.addEventListener('keydown', onKeyDown);
			//document.addEventListener('keyup', onKeyUp);

            document.addEventListener('mousedown', onMouseDown);
            //document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('mousemove', onPointerMove);

            const world = new GameWorld(10, 5);
            world.position.x -= 3;
            world.position.y += 3;
			scene.add(world);

			const states = [
                "Place",
                "Attack",
                "Move"
		    ];

			let gameState = 1;
			setGameState()

			let availableUnits = Math.trunc(world.ownedTerritories / 3);

            let selectedTerritory = null, attackTerritory = null;

            stateManager.pushState(new AttackState());

            $("#replayGame").click(function(event)
            {
                /*
                // for now keep this commented out because it's causing the game to randomly reload.
                // see #4
                console.log("reloading game in 5 seconds");
                
                setTimeout(function()
                {
                    location.reload();
                }, 5000);
                */
            });
			
			$("body").on("click", "#nextStateButton", function(event)
			{
			    console.log("next state");
			    
			    event.preventDefault();
			    
			    nextGameState();
			});
			
			$("#attackPlannerCancelButton").click(function(event)
			{
			    event.preventDefault();
			    
			    const id = selectedTerritory.id;
                            
                removeAttackDialog();
                createAttackDiagram(id);
			});
			
			$("#attackPlannerGoButton").click(function(event)
			{
			    if (selectedTerritory === null)
			    {
			        console.error("selectedTerritory is null.");
			        return;
			    }
			    
			    if (attackTerritory === null)
			    {
			        console.error("attackTerritory is null.");
			        return;
			    }
			    
			    console.log("Attacking!!!");
			    
			    while (attackTerritory.unitCount > 0 && selectedTerritory.unitCount > 1)
			    {
			        const attackerRoll = getRandomInt(5) + 1; // 1-6
			        const defenderRoll = getRandomInt(5) + 1; // 1-6
			        
			        if (attackerRoll > defenderRoll)
			        {
			            attackTerritory.unitCount -= 1;
			            console.log("Defenders lost a unit, now at: " + attackTerritory.unitCount + ".");
			        }
		            else
		            {
		                selectedTerritory.unitCount -= 1;
		                console.log("Attackers lost a unit, now at: " + selectedTerritory.unitCount + ".");
		            }
		                
                    selectedTerritory.label.element.innerHTML = selectedTerritory.unitCount;
                    attackTerritory.label.element.innerHTML = attackTerritory.unitCount;
			    }
			    
			    console.log(`Final score: Attacker: ${selectedTerritory.unitCount}, Defender: ${attackTerritory.unitCount}`);
			    
			    if (attackTerritory.unitCount > 0 && selectedTerritory.unitCount > 0)
			    {
			        console.log("match was a draw");
			    }
			    else
			    {
    			    if (attackTerritory.unitCount > 0)
    			    {
    			        console.log("defenders won");
    			    }
    			    
    			    if (selectedTerritory.unitCount > 0)
    			    {
    			        console.log("attackers won");
    			        
    			        attackTerritory.userData.team = 1;
    			        attackTerritory.material.color.setHex(ownedColor);
    			        attackTerritory.unitCount = selectedTerritory.unitCount - 1;
    			        selectedTerritory.unitCount = 1;
    			        
    			        selectedTerritory.label.element.innerHTML = selectedTerritory.unitCount;
                        attackTerritory.label.element.innerHTML = attackTerritory.unitCount;
                        
                        world.ownedTerritories += 1;
    			        
    			        console.log(`New unit allocation: Attacker: ${selectedTerritory.unitCount}, Defender: ${attackTerritory.unitCount}`);
    			    }
			    }
			    
			    finishAttack();
			});
			
			/*
			function nextGameState()
			{
			    if (gameState >= 2)
			        gameState = 0;
			    else
			        gameState += 1;

                if (gameState == 0)
                {
        			availableUnits = Math.trunc(world.ownedTerritories / 3);
        			$("#count").html(availableUnits);
                }
                else if (gameState == 1)
                {
                    if (attackTerritory !== null)
                        removeAttackDialog();
                }
			        
                setGameState();
			}
			*/
			
			function setGameState()
			{
			    $(".roundSpace.active").removeClass("active");
			    $("#roundType").children()[gameState].classList.add("active");
			    $("#roundName").html(states[gameState]);
			    
			    $(".gameStatus").attr("data-state", gameState);
			}
			
			function finishAttack()
			{
			    if (world.ownedTerritories == world.tiles.length)
			    {
			        $("#gameWin").attr("data-visibility", "shown");
			        return;
			    }
			    else
			        console.log(`Owned Territories: ${world.ownedTerritories} out of ${world.tiles.length}`);
			    
			    if (attackTerritory === null)
			    {
			        console.error("attackTerritory is null.");
			        return;
			    }
			    
			    if (selectedTerritory === null)
			    {
			        console.error("selectedTerritory is null.");
			        return;
			    }
			    
                for (const tile of selectedTerritory.getInvadeableNeighbors())
                {
                    if (!(tile instanceof WorldObject))
                        continue;
                    
		            if (tile != attackTerritory)
                        tile.material.color.setHex(enemyColor);
			    }
			    
			    if (attackTerritory.userData.team == 1)
                    attackTerritory.material.color.setHex(ownedColor);
                else
                    attackTerritory.material.color.setHex(enemyColor);
                    
                attackTerritory.lower();
                attackTerritory = null;
                
			    selectedTerritory.lower();
			    selectedTerritory.material.color.setHex(ownedColor);
                selectedTerritory = null;
                
                world.calculateInvadeableTerritories();
                
                $(".gameInterfaceContainer").attr("data-visibility", null);
			}
			
            function onMouseDown(event)
            {
                if (INTERSECTED == null)
                    return;
                    
                stateManager.onMouseDown(event, INTERSECTED);
            }
            
            function onKeyDown(event)
            {
                stateManager.onKeyDown(event);
                
                if (event.code == "Space")
                    nextGameState();
            }
			
            function onPointerMove(event)
            {
            	pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
            	pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
            }
			
			function onWindowResize()
			{
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize(window.innerWidth, window.innerHeight);
				htmlRenderer.setSize(window.innerWidth, window.innerHeight);
			}
			
			function animate()
			{
				requestAnimationFrame(animate);
				
            	raycaster.setFromCamera(pointer, camera);
            	const intersects = raycaster.intersectObjects(scene.children, true);
            
            	if (intersects.length > 0)
            	{
            		if (INTERSECTED != intersects[0].object)
            		{
            			if (INTERSECTED) // the object is no longer hovered, and we're hovering over another object
            			{
            			    stateManager.onStopHover(INTERSECTED);
            			    INTERSECTED = null;
            			}
            
                        if (intersects[0].object.userData.hasOwnProperty("canClick")) // the object is now hovered
                        {
            				INTERSECTED = intersects[0].object;
                            stateManager.onHover(INTERSECTED);
                        }
            		}
            	}
            	else if (INTERSECTED !== null)// the object is no longer hovered, and no object is hovered
            	{
            	    stateManager.onStopHover(INTERSECTED);
            		INTERSECTED = null;
            	}
            	
            	stateManager.update(clock.getElapsedTime());
                
				world.update(clock.getElapsedTime());
				
                camera.position.lerp(cameraPosition, 0.2);
				
				renderer.render(scene, camera);
				htmlRenderer.render(scene, camera);
			};
			
			if (!params.has("skipLoading"))
			{
    			setTimeout(function()
    			{
    				document.getElementById('loadingCover').style.opacity = '0';
    				
    				setTimeout(function() 
    				{
        				document.getElementById('loadingCover').remove();
    				}, 1000);
    			}, 1000);
			}
			
			animate();
		</script>
	</body>
</html>
